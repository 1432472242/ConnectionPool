#include"ConnectionPool.h"
#include"public.h"
#include<string>
using namespace std;
//线程安全的懒汉式单例函数接口
ConnectionPool* ConnectionPool::getConnectionPool()
{
	static ConnectionPool pool;
	return &pool;
 }

//从配置文件中加载配置项
bool  ConnectionPool::loadConfigFile()
{
	FILE* pf = fopen("mysql.ini","r");
	if (pf==nullptr)
	{
		LOG("mysql.ini file is not exist!");
		return false;
	}

	while (!feof(pf))
	{
		char line[1024] = { 0 };
		fgets(line,1024,pf);
		string str = line;
		int idx = str.find('=',0);
		if (idx == -1)
		{
			continue;
		}
		int endidx = str.find('\n',idx);
		string key = str.substr(0,idx);
		string value = str.substr(idx+1,endidx-idx-1);
		if (key == "ip") { _ip = value; }
		else if (key == "port") { _port = atoi(value.c_str()); }
		else if (key == "username") { _username = value; }
		else if (key == "password") {_password= value; }
		else if (key == "dbname") { _dbname =value; }
		else if (key == "initSize") {_initSize = atoi(value.c_str()); }
		else if (key == "maxSize") {_maxSize = atoi(value.c_str()); }
		else if (key == "maxIdleTime") { _maxIdleTime = atoi(value.c_str()); }
		else if (key == "connectionTimeOut") { _connectionTimeOut = atoi(value.c_str()); }
	}
	return true;
}

//连接池的构造函数
ConnectionPool::ConnectionPool()
{
    //加载配置项
	if (!loadConfigFile())
	{
		return;
	}

	//创建initSize数量的连接
	for (int i = 0; i < _initSize; ++i)
	{
		Connection* p = new Connection();
		p->connect(_ip,_port,_username,_password,_dbname);
		p->refreshAliveTime();//刷新一下空闲时间的起点
		_connectionQue.push(p);
		_connectionCnt++;
	}

	//启动一个新的线程，作为连接的生产者
	thread produce(std::bind(&ConnectionPool::produceConnectionTask,this));
	produce.detach();

	//开启一个线程，定时清理超过空闲时间的连接
	thread scaner(std::bind(&ConnectionPool::scannerConnectionTask, this));
	scaner.detach();
	



}

//运行在独立的线程中，专门负责生产新连接
void ConnectionPool::produceConnectionTask()
{
	for (;;)
	{
		unique_lock<mutex> lock(_queMutex);
		while (!_connectionQue.empty())
		{
			_cv.wait(lock);//队列不空，生产者进程进入等待状态，释放锁
		}
		//队列空，并且连接数量没有达到maxSize，继续创建新的连接
		if (_connectionCnt < _maxSize)
		{
			Connection* p = new Connection();
			p->connect(_ip, _port, _username, _password, _dbname);
			p->refreshAliveTime();//刷新一下空闲时间的起点
			_connectionQue.push(p);
			_connectionCnt++;
		}
		//通知消费者线程，可以消费连接了
		_cv.notify_all();

	}

	
}


//给外部提供接口，从连接池中获取一个可用的空闲连接
shared_ptr<Connection> ConnectionPool::getConnection()
{
	unique_lock<mutex> lock(_queMutex);
	while (_connectionQue.empty())
	{
		if (cv_status::timeout == _cv.wait_for(lock, chrono::milliseconds(_maxIdleTime)))
		{
			if (_connectionQue.empty())
			{
				LOG("获取空闲连接超时了...获取连接失败");
				return nullptr;
			}
		}
	}
	shared_ptr<Connection> sp(_connectionQue.front(),
		[&](Connection* pcon) {
			unique_lock<mutex> lock(_queMutex);//在服务器应用线程中调用的，所以要考虑队列的线程安全操作
			pcon->refreshAliveTime();//刷新一下空闲时间的起点
			_connectionQue.push(pcon);
		});
	_connectionQue.pop();
	_cv.notify_all();//消费完连接以后，通知生产者线程检查一下，如果队列为空，赶紧生产
	return sp;

}

void ConnectionPool::scannerConnectionTask()
{
	for (;;)
	{
		//sleep_for模拟定时效果
		std::this_thread::sleep_for(chrono::seconds(_maxIdleTime));

		//扫描整个队列，释放多余的连接
		unique_lock<mutex> lock(_queMutex);
		while (_connectionCnt > _initSize)
		{
			Connection* p = _connectionQue.front();
			if (p->getAliveTime() >= (_maxIdleTime * 1000))
			{
				_connectionQue.pop();
				_connectionCnt--;
				delete p;//调用~Connection（）释放连接
			}
			else
			{
				break;//队头连接没有超过_maxIdleTime，其他连接肯定没有
			}
		}

	}

}